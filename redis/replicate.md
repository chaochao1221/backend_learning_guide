# 主从复制

### 定义：
- 在 Redis 中，用户可以通过执行 SLAVEOF 命令或者设置 slaveof 选项，让一个服务器去复制（replicate）另一个服务器，我们称呼被复制的服务器为主服务器（master），而对主服务器进行复制的服务器则被称为从服务器（slave）。

### 旧版复制功能的实现（SYNC）

1. Redis的复制功能分为同步（sync）和命令传播（command propagate）两个操作：
    - 同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。
    - 命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。
2. 同步（sync）步骤：
    - 从服务器-发送SYNC命令->主服务器
    - 主服务器-执行BGSAVE命令，发送RDB文件->从服务器
    - 主服务器-发送缓冲区保存的所有写命令->从服务器
3.命令传播（command propagate）操作：主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态。

### 旧版复制功能的缺陷

1. 在Redis中，从服务器对主服务器的复制可以分为以下两种情况：
    - 初次复制：从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同。
    - 断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接重新连上了主服务器，并继续复制主服务器。
    对于初次复制来说，旧版复制功能能够很好地完成任务，但对于断线后重复制来说，旧版复制功能虽然也能让主从服务器重新回到一致状态，但效率却非常低。
2. SYNC命令是一个非常耗费资源的操作每次执行SYNC命令，主从服务器需要执行以下动作：
    - 主服务器需要执行BGSAVE命令来生成RDB文件，这个生成操作会耗费主服务器大量的CPU、内存和磁盘I/O资源。
    - 主服务器需要将自己生成的RDB文件发送给从服务器，这个发送操作会耗费主从服务器大量的网络资源（带宽和流量），并对主服务器响应命令请求的时间产生影响。3）接收到RDB文件的从服务器需要载入主服务器发来的RDB文件，并且在载入期间，从服务器会因为阻塞而没办法处理命令请求。因为SYNC命令是一个如此耗费资源的操作，所以Redis有必要保证在真正有需要时才执行SYNC命令。

### 新版复制功能的实现（PSYNC）

1. PSYNC命令具有完整重同步（full resynchronization）和部分重同步（partialresynchronization）两种模式：
    - 完整重同步：用于处理初次复制情况。完整重同步的执行步骤和SYNC命令的执行步骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步。
    - 部分重同步：用于处理断线后重复制情况。当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。
2. PSYNC命令的部分重同步模式解决了旧版复制功能在处理断线后重复制时出现的低效情况。

### 部分重同步的实现（PSYNC）

1. 部分重同步功能由以下三个部分构成：
    - 主服务器的复制偏移量（replication offset）和从服务器的复制偏移量。
    - 主服务器的复制积压缓冲区（replication backlog）。
    - 服务器的运行ID（run ID）。
2. 复制偏移量：
    - 执行复制的双方——主服务器和从服务器会分别维护一个复制偏移量。
    - 主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N。
    - 从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N。
    - 通过对比主从服务器的复制偏移量，程序可以很容易地知道主从服务器是否处于一致状态。
3. 复制积压缓冲区：
    - 复制积压缓冲区是由主服务器维护的一个固定长度（fixed-size）先进先出（FIFO）队列，默认大小为1MB。固定长度先进先出队列的长度是固定的，当入队元素的数量大于队列长度时，最先入队的元素会被弹出，而新元素会被放入队列。
    - 当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面。因此，主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量。
    - 当从服务器重新连上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作：
        - 如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）仍然存在于复制积压缓冲区里面，那么主服务器将对从服务器执行部分重同步操作。
        - 相反，如果offset偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器将对从服务器执行完整重同步操作。
4. 服务器运行ID：
    - 每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID。
    - 运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成，例如53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3。
    - 当从服务器断线并重新连上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行ID：
        - 如果从服务器保存的运行ID和当前连接的主服务器的运行ID相同，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操作。
        - 相反地，如果从服务器保存的运行ID和当前连接的主服务器的运行ID并不相同，那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作。

### PSYNC 命令的实现

1. PSYNC命令的调用方法：
    - 如果从服务器以前没有复制过任何主服务器，或者之前执行过SLAVEOF no one命令，那么从服务器在开始一次新的复制时将向主服务器发送PSYNC ? -1命令，主动请求主服务器进行完整重同步（因为这时不可能执行部分重同步）。
    - 相反地，如果从服务器已经复制过某个主服务器，那么从服务器在开始一次新的复制时将向主服务器发送PSYNC ＜runid＞ ＜offset＞命令：其中runid是上一次复制的主服务器的运行ID，而offset则是从服务器当前的复制偏移量，接收到这个命令的主服务器会通过这两个参数来判断应该对从服务器执行哪种同步操作。
2. PSYNC命令的回复的方法：
    - 如果主服务器返回+FULLRESYNC ＜runid＞ ＜offset＞回复，那么表示主服务器将与从服务器执行完整重同步操作：其中runid是这个主服务器的运行ID，从服务器会将这个ID保存起来，在下一次发送PSYNC命令时使用；而offset则是主服务器当前的复制偏移量，从服务器会将这个值作为自己的初始化偏移量。
    - 如果主服务器返回+CONTINUE回复，那么表示主服务器将与从服务器执行部分重同步操作，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了。
    - 如果主服务器返回-ERR回复，那么表示主服务器的版本低于Redis 2.8，它识别不了PSYNC命令。

### 复制的实现

1. 通过向从服务器发送SLAVEOF命令，我们可以让一个从服务器去复制一个主服务器：SLAVEOF <master_ip> <master_port>
2. 复制功能的实现步骤：
    - 设置主服务器的地址和端口：从服务器首先要做的就是将客户端给定的主服务器IP地址以及端口保存到服务器状态的masterhost属性和masterport属性里面。
    - 建立套接字连接：在SLAVEOF命令执行之后，从服务器将根据命令所设置的IP地址和端口，创建连向主服务器的套接字连接。
    - 发送PING命令：从服务器成为主服务器的客户端之后，做的第一件事就是向主服务器发送一个PING命令，检查套接字的读写状态是否正常以及检查主服务器能否正常处理命令请求。
    - 身份验证：从服务器在收到主服务器返回的"PONG"回复之后，下一步要做的就是决定是否进行身份验证。如果从服务器设置了masterauth选项，那么进行身份验证。如果从服务器没有设置masterauth选项，那么不进行身份验证。
    - 发送端口信息：在身份验证步骤之后，从服务器将执行命令REPLCONF listening-port ＜port-number＞，向主服务器发送从服务器的监听端口号。
    - 同步：从服务器将向主服务器发送PSYNC命令，执行同步操作，并将自己的数据库更新至主服务器数据库当前所处的状态。
    - 命令传播：同步完成之后，主服务器只要一直将自己执行的写命令发送给从服务器，而从服务器只要一直接收并执行主服务器发来的写命令，就可以保证主从服务器一直保持一致了。

### 心跳检测

1. 在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令：REPLCONF ACK <replication_offset>。其中replication_offset是从服务器当前的复制偏移量。
2. 发送REPLCONF ACK命令的作用：
    - 检测主从服务器的网络连接状态。
    - 辅助实现min-slaves配置选项。
    - 检测命令丢失。
3. 检测主从服务器的网络连接状态：主从服务器可以通过发送和接收REPLCONF ACK命令来检查两者之间的网络连接是否正常：如果主服务器超过一秒钟没有收到从服务器发来的REPLCONF ACK命令，那么主服务器就知道主从服务器之间的连接出现问题了。
4. 辅助实现min-slaves配置选项：Redis的min-slaves-to-write和min-slaves-max-lag两个选项可以防止主服务器在不安全的情况下执行写命令。
5. 检测命令丢失：当从服务器向主服务器发送REPLCONF ACK命令时，主服务器将发觉从服务器当前的复制偏移量少于自己的复制偏移量，然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据，并将这些数据重新发送给从服务器。

### 总结

1. Redis 2.8以前的复制功能不能高效地处理断线后重复制情况，但Redis2.8新添加的部分重同步功能可以解决这个问题。
2. 部分重同步通过复制偏移量、复制积压缓冲区、服务器运行ID三个部分来实现。
3. 在复制操作刚开始的时候，从服务器会成为主服务器的客户端，并通过向主服务器发送命令请求来执行复制步骤，而在复制操作的后期，主从服务器会互相成为对方的客户端。
4. 主服务器通过向从服务器传播命令来更新从服务器的状态，保持主从服务器一致，而从服务器则通过向主服务器发送命令来进行心跳检测，以及命令丢失检测。
